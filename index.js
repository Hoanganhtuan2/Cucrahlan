const TelegramBot = require('node-telegram-bot-api');
const fs = require('fs');
const axios = require('axios');

// --- CONFIG ---
const token = '8328121313:AAHV9V16SLf17VuT4PZza2lfG49hquIfM6U';
const ADMIN_ID = 7853576129;
const NOTIFY_GROUP_ID = '-1002817772823';
const bot = new TelegramBot(token, { polling: true });

// --- C·∫§U H√åNH N·∫†P TI·ªÄN ---
const ADMIN_BANK_NAME = 'MB Bank';
const ADMIN_BANK_ACCOUNT = '2916102009';
const ADMIN_BANK_OWNER = 'KSOR HUAN';

// --- LOAD COOKIE FROM key.txt ---
let TTC_COOKIE;
try {
    TTC_COOKIE = fs.readFileSync('key.txt', 'utf8').trim();
    if (!TTC_COOKIE) throw new Error('File key.txt is empty.');
} catch (error) {
    console.error("‚ùå ERROR: Unable to read cookie from key.txt. Please create key.txt and paste the cookie.");
    process.exit(1);
}

const TTC_USERNAME_NHAN = 'Vi_muabanxumxh';
const XU_TO_VND_RATE = 100;
const MIN_WITHDRAW_AMOUNT = 20000;
const MIN_TTC_SELL_AMOUNT = 10000;

// --- FILE PATHS ---
const NGUOIDUNG_FILE = './nguoidung.json';
const REF_FILE = './ref.json';
const LSALL_FILE = './lsall.json';
const CLAIMED_TTC_FILE = './claimed_ttc.json';

let userState = {};

// --- FILE READ/WRITE HELPERS ---
const readJSON = (filePath) => {
    try {
        if (!fs.existsSync(filePath)) {
            const defaultData = (filePath === NGUOIDUNG_FILE || filePath === CLAIMED_TTC_FILE) ? [] : {};
            fs.writeFileSync(filePath, JSON.stringify(defaultData, null, 2));
            return defaultData;
        }
        const data = fs.readFileSync(filePath, 'utf8');
        return data ? JSON.parse(data) : (filePath === NGUOIDUNG_FILE || filePath === CLAIMED_TTC_FILE) ? [] : {};
    } catch (error) {
        console.error(`Error reading file ${filePath}:`, error);
        return (filePath === NGUOIDUNG_FILE || filePath === CLAIMED_TTC_FILE) ? [] : {};
    }
};

const writeJSON = (filePath, data) => {
    try {
        fs.writeFileSync(filePath, JSON.stringify(data, null, 2), 'utf8');
    } catch (error) {
        console.error(`Error writing file ${filePath}:`, error);
    }
};

// --- ADMIN COMMANDS ---
bot.onText(/\/ct (.+) (.+)/, (msg, match) => {
    if (msg.from.id !== ADMIN_ID) return;
    const targetId = parseInt(match[1]);
    const amount = parseInt(match[2]);
    let data = readJSON(NGUOIDUNG_FILE);
    const userIndex = data.findIndex(u => u.id === targetId);
    if (userIndex === -1) return bot.sendMessage(msg.chat.id, `‚ùå User ID not found: ${targetId}`);
    data[userIndex].sodu += amount;
    writeJSON(NGUOIDUNG_FILE, data);
    bot.sendMessage(msg.chat.id, `‚úÖ Added <b>${amount.toLocaleString('vi-VN')} ƒë</b> to user ID <code>${targetId}</code>.`, { parse_mode: 'HTML' });
    bot.sendMessage(targetId, `üéâ Admin added <b>${amount.toLocaleString('vi-VN')} ƒë</b> to your account.`, { parse_mode: 'HTML' }).catch(() => {});
});

bot.onText(/\/tt (.+) (.+)/, (msg, match) => {
    if (msg.from.id !== ADMIN_ID) return;
    const targetId = parseInt(match[1]);
    const amount = parseInt(match[2]);
    let data = readJSON(NGUOIDUNG_FILE);
    const userIndex = data.findIndex(u => u.id === targetId);
    if (userIndex === -1) return bot.sendMessage(msg.chat.id, `‚ùå User ID not found: ${targetId}`);
    data[userIndex].sodu -= amount;
    writeJSON(NGUOIDUNG_FILE, data);
    bot.sendMessage(msg.chat.id, `‚úÖ Deducted <b>${amount.toLocaleString('vi-VN')} ƒë</b> from user ID <code>${targetId}</code>.`, { parse_mode: 'HTML' });
    bot.sendMessage(targetId, `‚ùóÔ∏è Admin deducted <b>${amount.toLocaleString('vi-VN')} ƒë</b> from your account.`, { parse_mode: 'HTML' }).catch(() => {});
});

bot.onText(/\/kttk/, (msg) => {
    if (msg.from.id !== ADMIN_ID) return;
    const opts = {
        reply_markup: {
            inline_keyboard: [
                [
                    { text: 'üîπ TDS', callback_data: 'check_tokens_tds' },
                    { text: 'üî∏ TTC', callback_data: 'check_tokens_ttc' }
                ]
            ]
        }
    };
    bot.sendMessage(msg.chat.id, 'üîç Ch·ªçn n·ªÅn t·∫£ng ƒë·ªÉ ki·ªÉm tra token:', opts);
});

// --- CALLBACK QUERY HANDLER ---
bot.on('callback_query', async (callbackQuery) => {
    const data = callbackQuery.data;
    const msg = callbackQuery.message;
    const userId = callbackQuery.from.id;
    const chatId = msg.chat.id;

    // --- TTC TOKEN CHECK ---
    if (data === 'check_tokens_ttc') {
        try {
            const tokens = fs.readFileSync('tokenttc.txt', 'utf8').split('\n').map(t => t.trim()).filter(Boolean);
            if (tokens.length === 0)
                return bot.editMessageText('‚ö†Ô∏è Kh√¥ng c√≥ token TTC n√†o trong file tokenttc.txt.', {
                    chat_id: chatId, message_id: msg.message_id
                });

            let result = 'üìã <b>K·∫æT QU·∫¢ TTC</b>\n\n';
            for (const token of tokens) {
                try {
                    const res = await axios.post('https://tuongtaccheo.com/logintoken.php', new URLSearchParams({
                        access_token: token
                    }).toString(), {
                        headers: { 'Content-Type': 'application/x-www-form-urlencoded' }
                    });

                    if (res.data.status === 'success') {
                        const u = res.data.data;
                        result += `‚úÖ <b>${u.user}</b>: <code>${parseInt(u.sodu).toLocaleString('vi-VN')} xu</code>\n`;
                    } else {
                        result += `‚ùå Token: ${token.slice(0, 6)}... l·ªói\n`;
                    }
                } catch {
                    result += `‚ùå Token: ${token.slice(0, 6)}... l·ªói k·∫øt n·ªëi\n`;
                }
            }

            bot.editMessageText(result, {
                chat_id: chatId, message_id: msg.message_id, parse_mode: 'HTML'
            });
        } catch (err) {
            bot.editMessageText('‚ùå L·ªói ƒë·ªçc file tokenttc.txt', {
                chat_id: chatId, message_id: msg.message_id
            });
        }
    }

    // --- TDS TOKEN CHECK ---
    if (data === 'check_tokens_tds') {
        try {
            const tokens = fs.readFileSync('tokentds.txt', 'utf8').split('\n').map(t => t.trim()).filter(Boolean);
            if (tokens.length === 0)
                return bot.editMessageText('‚ö†Ô∏è Kh√¥ng c√≥ token TDS n√†o trong file tokentds.txt.', {
                    chat_id: chatId, message_id: msg.message_id
                });

            let result = 'üìã <b>K·∫æT QU·∫¢ TDS</b>\n\n';
            for (const token of tokens) {
                try {
                    const res = await axios.get(`https://traodoisub.com/api/?fields=profile&access_token=${token}`);
                    const u = res.data.data;
                    if (res.data.success === 200 && u && u.user) {
                        result += `‚úÖ <b>${u.user}</b>: <code>${parseInt(u.xu).toLocaleString('vi-VN')} xu</code>\n`;
                    } else {
                        result += `‚ùå Token: ${token.slice(0, 6)}... l·ªói\n`;
                    }
                } catch {
                    result += `‚ùå Token: ${token.slice(0, 6)}... l·ªói k·∫øt n·ªëi\n`;
                }
            }

            bot.editMessageText(result, {
                chat_id: chatId, message_id: msg.message_id, parse_mode: 'HTML'
            });
        } catch (err) {
            bot.editMessageText('‚ùå L·ªói ƒë·ªçc file tokentds.txt', {
                chat_id: chatId, message_id: msg.message_id
            });
        }
    }

    // --- DEPOSIT HANDLER ---
    if (data === 'deposit_bank') {
        const depositInfo = `
‚úÖ <b>N·∫†P TI·ªÄN V√ÄO T√ÄI KHO·∫¢N</b>

Vui l√≤ng chuy·ªÉn kho·∫£n ƒë·∫øn th√¥ng tin sau:
-----------------------------------
üè¶ <b>Ng√¢n h√†ng:</b> <code>${ADMIN_BANK_NAME}</code>
üí≥ <b>S·ªë t√†i kho·∫£n:</b> <code>${ADMIN_BANK_ACCOUNT}</code>
üë§ <b>Ch·ªß t√†i kho·∫£n:</b> ${ADMIN_BANK_OWNER}
-----------------------------------
‚ùóÔ∏è <b>N·ªôi dung chuy·ªÉn kho·∫£n B·∫ÆT BU·ªòC:</b>
<code>NAP ${userId}</code>
-----------------------------------
Sau khi chuy·ªÉn kho·∫£n, vui l√≤ng ch·ªù admin x√°c nh·∫≠n v√† c·ªông ti·ªÅn th·ªß c√¥ng.`;
        await bot.editMessageText(depositInfo, {
            chat_id: chatId, message_id: msg.message_id, parse_mode: 'HTML',
            reply_markup: { inline_keyboard: [[{ text: 'OK', callback_data: 'close_message' }]] }
        }).catch(err => console.log(err.message));
        return bot.answerCallbackQuery(callbackQuery.id);
    }

    if (data === 'close_message') {
        try {
            await bot.deleteMessage(chatId, msg.message_id);
        } catch (error) {
            console.error(`Error deleting message: ${error.message}`);
        }
        return bot.answerCallbackQuery(callbackQuery.id);
    }

    // --- Deposit/Withdraw Choice Handlers ---
    if (data === 'deposit') {
        await bot.editMessageText('B·∫°n ƒë√£ ch·ªçn <b>N·∫°p ti·ªÅn</b>. Vui l√≤ng ch·ªçn ph∆∞∆°ng th·ª©c:', {
            chat_id: chatId, message_id: msg.message_id, parse_mode: 'HTML',
            reply_markup: { inline_keyboard: [[{ text: 'üè¶ Ng√¢n H√†ng', callback_data: 'deposit_bank' }]] }
        });
        return bot.answerCallbackQuery(callbackQuery.id);
    }

    if (data === 'withdraw') {
        await bot.editMessageText('B·∫°n ƒë√£ ch·ªçn <b>R√∫t ti·ªÅn</b>. Vui l√≤ng ch·ªçn ph∆∞∆°ng th·ª©c:', {
            chat_id: chatId, message_id: msg.message_id, parse_mode: 'HTML',
            reply_markup: { inline_keyboard: [[{ text: 'üè¶ Ng√¢n H√†ng', callback_data: 'withdraw_bank' }]] }
        });
        return bot.answerCallbackQuery(callbackQuery.id);
    }

    if (data === 'withdraw_bank') {
        try {
            await bot.deleteMessage(chatId, msg.message_id);
        } catch (error) {
            console.error(`Error deleting message: ${error.message}`);
        }
        handleRutBank(chatId, userId);
        return bot.answerCallbackQuery(callbackQuery.id);
    }

    // --- BANK SELECTION FOR WITHDRAWAL ---
    if (data.startsWith('chonbank_')) {
        const code = data.split('_')[1];
        const banks = await getBanks();
        const bank = banks.find(b => b.code === code);
        if (!bank) { return bot.answerCallbackQuery(callbackQuery.id, { text: 'Ng√¢n h√†ng kh√¥ng t·ªìn t·∫°i' }); }

        userState[userId] = {
            action: 'awaiting_stk',
            bankCode: bank.code,
            bankName: bank.name,
            bankShortName: bank.shortName,
            logo: bank.logo
        };

        try {
            await bot.deleteMessage(chatId, msg.message_id);
        } catch (error) {
            console.error(`Error deleting message: ${error.message}`);
        }
        await bot.sendPhoto(chatId, bank.logo, {
            caption: `üè¶ <b>Ng√¢n h√†ng: ${bank.name}</b>\n\n‚û°Ô∏è Vui l√≤ng nh·∫≠p <b>S·ªë T√†i Kho·∫£n (STK)</b> c·ªßa b·∫°n:`,
            parse_mode: 'HTML'
        });
        return bot.answerCallbackQuery(callbackQuery.id);
    }

    // --- ADMIN CONFIRMS WITHDRAWAL ---
    if (data.startsWith('admin_xacnhanrut_')) {
        const parts = data.split('_');
        const targetUserId = parseInt(parts[2], 10);
        const sotien = parseInt(parts[3], 10);
        const bankCode = parts[4];
        const stk = parts[5];

        if (isNaN(targetUserId) || isNaN(sotien)) {
            bot.answerCallbackQuery(callbackQuery.id, { text: '‚ùå L·ªói: D·ªØ li·ªáu giao d·ªãch kh√¥ng h·ª£p l·ªá.', show_alert: true });
            return bot.editMessageCaption('‚ùå L·ªñI D·ªÆ LI·ªÜU GIAO D·ªäCH\nKh√¥ng th·ªÉ x·ª≠ l√Ω do sai ƒë·ªãnh d·∫°ng. Vui l√≤ng ki·ªÉm tra l·∫°i.', {
                chat_id: msg.chat.id, message_id: msg.message_id
            });
        }

        const banks = await getBanks();
        const bank = banks.find(b => b.code === bankCode);
        const bankShortName = bank ? bank.shortName : bankCode;

        await bot.answerCallbackQuery(callbackQuery.id, { text: '‚úÖ ƒê√£ x√°c nh·∫≠n. ƒêang g·ª≠i th√¥ng b√°o...' });

        bot.sendMessage(targetUserId, `üéâ <b>R√∫t ti·ªÅn th√†nh c√¥ng</b>\n\nB·∫°n ƒë√£ r√∫t th√†nh c√¥ng <b>${sotien.toLocaleString('vi-VN')}ƒë</b> v·ªÅ t√†i kho·∫£n <b>${stk} (${bankShortName})</b>. ‚úÖ`, { parse_mode: 'HTML' }).catch(err => console.error("Error notifying user:", err.message));
        bot.sendMessage(NOTIFY_GROUP_ID, `Ng∆∞·ªùi D√πng: <code>${targetUserId}</code>\nR√∫t Th√†nh C√¥ng ${sotien.toLocaleString('vi-VN')}ƒë ‚úÖ`, { parse_mode: 'HTML' }).catch(err => console.error("Error notifying group:", err.message));

        let lsData = readJSON(LSALL_FILE);
        const time = new Date();
        const formattedDate = `${time.getDate()}/${time.getMonth() + 1}/${time.getFullYear()}`;
        const lsEntry = `R√∫t ${sotien.toLocaleString('vi-VN')}ƒë v·ªÅ STK ${stk} (${bankShortName}) ng√†y ${formattedDate} Th√†nh C√¥ng ‚úÖ`;
        if (!lsData[targetUserId]) lsData[targetUserId] = { ls_rut: [], ls_nap: [], ls_mua_xu: [], ls_ban_xu: [] };
        if (!lsData[targetUserId].ls_rut) lsData[targetUserId].ls_rut = [];
        lsData[targetUserId].ls_rut.push(lsEntry);
        writeJSON(LSALL_FILE, lsData);

        return bot.editMessageCaption(`‚úÖ <b>ƒê√É X·ª¨ L√ù R√öT TI·ªÄN</b>\n\nüë§ ID: <code>${targetUserId}</code>\nüè¶ Ng√¢n h√†ng: ${bankShortName}\nüî¢ STK: <code>${stk}</code>\nüí∞ S·ªë ti·ªÅn: <code>${sotien.toLocaleString('vi-VN')}ƒë</code>`, {
            chat_id: msg.chat.id, message_id: msg.message_id, parse_mode: 'HTML'
        });
    }

    // --- BUY/SELL HANDLERS ---
    if (data === 'buy' || data === 'sell') {
        const tradeType = (data === 'buy') ? 'Mua' : 'B√°n';
        bot.editMessageText(`B·∫°n ƒë√£ ch·ªçn <b>${tradeType}</b>. Vui l√≤ng ch·ªçn lo·∫°i giao d·ªãch:`, {
            chat_id: chatId, message_id: msg.message_id, parse_mode: 'HTML',
            reply_markup: { inline_keyboard: [[{ text: 'TDS', callback_data: `${data}_tds` }, { text: 'TTC', callback_data: `${data}_ttc` }]] }
        });
        return bot.answerCallbackQuery(callbackQuery.id);
    }

    // --- TTC SELL HANDLER ---
    if (data === 'sell_ttc') {
        userState[userId] = { action: 'sell_ttc', step: 'awaiting_username' };
        bot.sendMessage(chatId, "‚û°Ô∏è Vui l√≤ng nh·∫≠p <b>T√™n t√†i kho·∫£n T∆∞∆°ng T√°c Ch√©o c·ªßa b·∫°n</b>:", { parse_mode: 'HTML' });
        return bot.answerCallbackQuery(callbackQuery.id);
    }

    if (data.startsWith('confirm_sell_ttc_')) {
        await bot.answerCallbackQuery(callbackQuery.id, { text: 'üîç ƒêang ki·ªÉm tra giao d·ªãch...' });
        const parts = data.split('_');
        const usertang = parts[3];
        const soluong = parseInt(parts[4]);

        const url = 'https://tuongtaccheo.com/caidat/lichsutangxu.php';
        const headers = { 'Accept': '*/*', 'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8', 'Origin': 'https://tuongtaccheo.com', 'Referer': 'https://tuongtaccheo.com/caidat/', 'User-Agent': 'Mozilla/5.0', 'X-Requested-With': 'XMLHttpRequest', 'Cookie': TTC_COOKIE };
        const startTime = new Date(new Date().getTime() - 4 * 60 * 60 * 1000);
        const endTime = new Date();
        const formatDateTime = (date) => `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')} ${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}`;
        const params = new URLSearchParams({ start: formatDateTime(startTime), end: formatDateTime(endTime), loaihd: 'nhan' });

        try {
            const response = await axios.post(url, params.toString(), { headers });

            if (typeof response.data === 'number' || !Array.isArray(response.data)) {
                await bot.editMessageText(`‚ùå <b>L·ªói X√°c Th·ª±c</b>\n\nCookie trong file <b>key.txt</b> ƒë√£ h·∫øt h·∫°n ho·∫∑c kh√¥ng h·ª£p l·ªá. Vui l√≤ng c·∫≠p nh·∫≠t l·∫°i cookie v√† kh·ªüi ƒë·ªông l·∫°i bot.`, { chat_id: chatId, message_id: msg.message_id, parse_mode: 'HTML' });
                return;
            }

            const claimedTxs = readJSON(CLAIMED_TTC_FILE);
            const validTx = response.data.find(tx => tx.usertang.toLowerCase() === usertang.toLowerCase() && parseInt(tx.soluong) === soluong && tx.usernhan.toLowerCase() === TTC_USERNAME_NHAN.toLowerCase() && tx.loai === 'XU' && !claimedTxs.includes(tx.thoigian));

            if (validTx) {
                const soduThem = Math.floor(soluong / XU_TO_VND_RATE);
                let allUsers = readJSON(NGUOIDUNG_FILE);
                let userIdx = allUsers.findIndex(u => u.id === userId);

                if (userIdx !== -1) {
                    allUsers[userIdx].sodu += soduThem;
                    allUsers[userIdx].tongxuban += soluong;
                    writeJSON(NGUOIDUNG_FILE, allUsers);

                    let lsData = readJSON(LSALL_FILE);
                    const time = new Date();
                    const formattedDate = `${time.getDate()}/${time.getMonth() + 1}/${time.getFullYear()}`;
                    const lsEntry = `${usertang} TTC: +${soduThem.toLocaleString('vi-VN')}ƒë ng√†y ${formattedDate} Th√†nh C√¥ng ‚úÖ`;
                    if (!lsData[userId]) lsData[userId] = { ls_rut: [], ls_nap: [], ls_mua_xu: [], ls_ban_xu: [] };
                    lsData[userId].ls_ban_xu.push(lsEntry);
                    writeJSON(LSALL_FILE, lsData);

                    claimedTxs.push(validTx.thoigian);
                    writeJSON(CLAIMED_TTC_FILE, claimedTxs);

                    const notifyMessage = `
üéâ <b>GIAO D·ªäCH B√ÅN XU M·ªöI</b> üéâ
-----------------------------------
üë§ <b>Ng∆∞·ªùi d√πng ID:</b> <code>${userId}</code>
üë®‚Äçüíª <b>T√†i kho·∫£n TTC:</b> <code>${usertang}</code>
üí∞ <b>S·ªë l∆∞·ª£ng b√°n:</b> ${soluong.toLocaleString('vi-VN')} xu
üíµ <b>Ti·ªÅn nh·∫≠n ƒë∆∞·ª£c:</b> +${soduThem.toLocaleString('vi-VN')} ƒë
‚úÖ <b>Tr·∫°ng th√°i:</b> Th√†nh C√¥ng
                    `;
                    bot.sendMessage(NOTIFY_GROUP_ID, notifyMessage, { parse_mode: 'HTML' })
                        .catch(err => console.error("L·ªói g·ª≠i tin nh·∫Øn ƒë·∫øn nh√≥m:", err.message));

                    await bot.editMessageText(
                        `<b>GIAO D·ªäCH TH√ÄNH C√îNG</b> ‚úÖ\n\n` +
                        `N·ªôi dung: <b>B√°n ${soluong.toLocaleString('vi-VN')} xu TTC</b>\n` +
                        `Nh·∫≠n ƒë∆∞·ª£c: <b>+${soduThem.toLocaleString('vi-VN')} ƒë</b>\n` +
                        `Th·ªùi gian: <b>${time.toLocaleString('vi-VN')}</b>`,
                        { chat_id: chatId, message_id: msg.message_id, parse_mode: 'HTML' }
                    );
                }
            } else {
                await bot.editMessageText(`‚ùå <b>KH√îNG T√åM TH·∫§Y GIAO D·ªäCH</b>\n\nVui l√≤ng ki·ªÉm tra l·∫°i:\n- B·∫°n ƒë√£ chuy·ªÉn xu <b>TR∆Ø·ªöC KHI</b> b·∫•m n√∫t.\n- Chuy·ªÉn ƒë√∫ng <b>s·ªë xu</b> v√† ƒë√∫ng <b>ng∆∞·ªùi nh·∫≠n</b>.\n- Giao d·ªãch n√†y ch∆∞a ƒë∆∞·ª£c x√°c nh·∫≠n tr∆∞·ªõc ƒë√¢y.`, { chat_id: chatId, message_id: msg.message_id, parse_mode: 'HTML' });
            }
        } catch (error) {
            console.error("L·ªói API:", error.message);
            await bot.editMessageText('‚ùå ƒê√£ c√≥ l·ªói khi k·∫øt n·ªëi t·ªõi h·ªá th·ªëng T∆∞∆°ng T√°c Ch√©o.', { chat_id: chatId, message_id: msg.message_id });
        }
        return;
    }

    // --- HISTORY HANDLERS ---
    if (data.startsWith('ls_')) {
        const lsallData = readJSON(LSALL_FILE);
        const userHistory = lsallData[userId] || {};
        let historyType = '', historyList = [];
        switch (data) {
            case 'ls_rut': historyType = 'R√∫t Ti·ªÅn'; historyList = userHistory.ls_rut || []; break;
            case 'ls_nap': historyType = 'N·∫°p Ti·ªÅn'; historyList = userHistory.ls_nap || []; break;
            case 'ls_mua_xu': historyType = 'Mua Xu'; historyList = userHistory.ls_mua_xu || []; break;
            case 'ls_ban_xu': historyType = 'B√°n Xu'; historyList = userHistory.ls_ban_xu || []; break;
        }
        let historyMessage = `<b>L·ªãch s·ª≠ ${historyType}</b>\n\n` + (historyList.length > 0 ? historyList.map(item => `‚Ä¢ ${item}`).join('\n') : 'Ch∆∞a c√≥ giao d·ªãch n√†o.');
        bot.editMessageText(historyMessage, {
            chat_id: chatId, message_id: msg.message_id, parse_mode: 'HTML',
            reply_markup: { inline_keyboard: [[{ text: '‚¨ÖÔ∏è Quay l·∫°i', callback_data: 'back_to_account' }]] }
        });
        return bot.answerCallbackQuery(callbackQuery.id);
    }

    if (data === 'back_to_account') {
        const nguoidungData = readJSON(NGUOIDUNG_FILE);
        const user = nguoidungData.find(u => u.id === userId);
        if (!user) return bot.answerCallbackQuery(callbackQuery.id);
        const accountInfo = `<b>--- T√ÄI KHO·∫¢N ---</b>\nüÜî <b>ID:</b> <code>${user.id}</code>\nüí∞ <b>S·ªë d∆∞:</b> <code>${user.sodu.toLocaleString('vi-VN')} ƒë</code>\nüåπ <b>T·ªïng hoa h·ªìng:</b> <code>${user.tonghoahong.toLocaleString('vi-VN')} ƒë</code>`;
        bot.editMessageText(accountInfo, {
            chat_id: chatId, message_id: msg.message_id, parse_mode: 'HTML',
            reply_markup: { inline_keyboard: [[{ text: 'LS R√∫t Ti·ªÅn', callback_data: 'ls_rut' }, { text: 'LS N·∫°p Ti·ªÅn', callback_data: 'ls_nap' }], [{ text: 'LS Mua Xu', callback_data: 'ls_mua_xu' }, { text: 'LS B√°n Xu', callback_data: 'ls_ban_xu' }]] }
        });
        return bot.answerCallbackQuery(callbackQuery.id);
    }

    await bot.answerCallbackQuery(callbackQuery.id).catch(() => {});
});

// --- START COMMAND ---
bot.onText(/\/start/, (msg) => {
    const userId = msg.from.id;
    let nguoidungData = readJSON(NGUOIDUNG_FILE);
    if (!nguoidungData.find(u => u.id === userId)) {
        if (!Array.isArray(nguoidungData)) nguoidungData = [];
        nguoidungData.push({ id: userId, sodu: 0, tongxuban: 0, tongxumua: 0, tongnap: 0, tongrut: 0, tonghoahong: 0 });
        writeJSON(NGUOIDUNG_FILE, nguoidungData);
    }
    bot.getMe().then((botInfo) => {
        const welcomeMessage = `üëã Ch√†o M·ª´ng B·∫°n ƒê·∫øn V·ªõi @${botInfo.username}\nüÜî ID c·ªßa b·∫°n: <code>${userId}</code>`;
        bot.sendMessage(msg.chat.id, welcomeMessage, {
            reply_markup: { keyboard: [[{ text: 'üë§ T√†i kho·∫£n' }, { text: 'üîÑ Mua B√°n' }], [{ text: 'üí≥ N·∫°p R√∫t' }, { text: 'ü§ù M·ªùi B·∫°n' }]], resize_keyboard: true },
            parse_mode: 'HTML'
        });
    });
});

// --- THONGKE COMMAND ---
bot.onText(/\/thongke/, (msg) => {
    if (msg.from.id !== ADMIN_ID) return;
    const data = readJSON(NGUOIDUNG_FILE);
    const totalUsers = data.length;
    const totalSodu = data.reduce((sum, user) => sum + user.sodu, 0);
    const statsMessage = `üìä <b>TH·ªêNG K√ä H·ªÜ TH·ªêNG</b>\n-------------------\nüë• <b>T·ªïng ng∆∞·ªùi d√πng:</b> ${totalUsers}\nüí∞ <b>T·ªïng s·ªë d∆∞:</b> ${totalSodu.toLocaleString('vi-VN')} ƒë`;
    bot.sendMessage(msg.chat.id, statsMessage, { parse_mode: 'HTML' });
});

// --- MAIN MESSAGE HANDLER ---
bot.on('message', async (msg) => {
    const chatId = msg.chat.id;
    const userId = msg.from.id;
    const text = msg.text;

    if (!text || text.startsWith('/')) return;

    const state = userState[userId];

    // --- Multi-step Bank Withdraw Process ---
    if (state && state.action === 'awaiting_stk') {
        const stk = text.trim();
        if (!/^\d+$/.test(stk)) { return bot.sendMessage(chatId, "‚ùå S·ªë t√†i kho·∫£n kh√¥ng h·ª£p l·ªá. Vui l√≤ng ch·ªâ nh·∫≠p s·ªë."); }
        state.stk = stk;
        state.action = 'awaiting_amount';
        bot.sendMessage(chatId, `‚úÖ ƒê√£ ghi nh·∫≠n STK: <b>${stk}</b>\n\n‚û°Ô∏è Vui l√≤ng nh·∫≠p <b>s·ªë ti·ªÅn</b> b·∫°n mu·ªën r√∫t (T·ªëi thi·ªÉu: ${MIN_WITHDRAW_AMOUNT.toLocaleString('vi-VN')}ƒë):`, { parse_mode: 'HTML' });
        return;
    }

    if (state && state.action === 'awaiting_amount') {
        const amount = parseInt(text.trim(), 10);
        if (isNaN(amount) || amount < MIN_WITHDRAW_AMOUNT) {
            return bot.sendMessage(chatId, `‚ùå S·ªë ti·ªÅn kh√¥ng h·ª£p l·ªá ho·∫∑c d∆∞·ªõi m·ª©c t·ªëi thi·ªÉu <b>${MIN_WITHDRAW_AMOUNT.toLocaleString('vi-VN')}ƒë</b>. Vui l√≤ng nh·∫≠p l·∫°i.`, { parse_mode: 'HTML' });
        }

        const nguoidungData = readJSON(NGUOIDUNG_FILE);
        const user = nguoidungData.find(u => u.id === userId);
        if (!user || user.sodu < amount) {
            delete userState[userId];
            return bot.sendMessage(chatId, '‚ùå S·ªë d∆∞ c·ªßa b·∫°n kh√¥ng ƒë·ªß ƒë·ªÉ th·ª±c hi·ªán giao d·ªãch n√†y.');
        }

        user.sodu -= amount;
        writeJSON(NGUOIDUNG_FILE, nguoidungData);

        const callbackData = `admin_xacnhanrut_${userId}_${amount}_${state.bankCode}_${state.stk}`;
        const qrUrl = `https://img.vietqr.io/image/${state.bankCode}-${state.stk}-compact.jpg?amount=${amount}&addInfo=Rut tien cho ${userId}`;
        const adminMsg = `<b>üì§ Y√äU C·∫¶U R√öT TI·ªÄN M·ªöI</b>\n\n` +
                        `üë§ <b>ID Ng∆∞·ªùi d√πng:</b> <code>${userId}</code>\n` +
                        `üè¶ <b>Ng√¢n h√†ng:</b> ${state.bankName}\n` +
                        `üî¢ <b>STK:</b> <code>${state.stk}</code>\n` +
                        `üí∞ <b>S·ªë ti·ªÅn:</b> <code>${amount.toLocaleString('vi-VN')} ƒë</code>`;

        const confirmBtn = {
            reply_markup: { inline_keyboard: [[{ text: '‚úÖ ƒê√£ chuy·ªÉn', callback_data: callbackData }]] }
        };

        try {
            await bot.sendPhoto(ADMIN_ID, qrUrl, { caption: adminMsg, parse_mode: 'HTML', ...confirmBtn });
        } catch (error) {
            console.error("Error sending QR to admin:", error.message);
            await bot.sendMessage(ADMIN_ID, adminMsg, { parse_mode: 'HTML', ...confirmBtn });
        }
        bot.sendMessage(chatId, '‚úÖ ƒê√£ g·ª≠i y√™u c·∫ßu r√∫t ti·ªÅn c·ªßa b·∫°n ƒë·∫øn Admin. Giao d·ªãch s·∫Ω ƒë∆∞·ª£c x·ª≠ l√Ω trong th·ªùi gian s·ªõm nh·∫•t.');

        delete userState[userId];
        return;
    }

    // --- TTC SELL PROCESS ---
    if (state && state.action === 'sell_ttc') {
        if (state.step === 'awaiting_username') {
            userState[userId].ttcUsername = text.trim();
            userState[userId].step = 'awaiting_amount';
            bot.sendMessage(chatId, `‚úÖ ƒê√£ ghi nh·∫≠n t√™n t√†i kho·∫£n.\n\n‚û°Ô∏è Vui l√≤ng nh·∫≠p <b>s·ªë xu</b> b·∫°n mu·ªën b√°n (T·ªëi thi·ªÉu: ${MIN_TTC_SELL_AMOUNT.toLocaleString('vi-VN')} xu):`, { parse_mode: 'HTML' });
            return;
        }
        if (state.step === 'awaiting_amount') {
            const amount = parseInt(text.trim(), 10);
            if (isNaN(amount) || amount < MIN_TTC_SELL_AMOUNT) {
                bot.sendMessage(chatId, `‚ùå S·ªë xu kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p s·ªë xu t·ªëi thi·ªÉu ${MIN_TTC_SELL_AMOUNT.toLocaleString('vi-VN')}.`, { parse_mode: 'HTML' });
                return;
            }
            const ttcUsername = userState[userId].ttcUsername;
            const soduNhanDuoc = Math.floor(amount / XU_TO_VND_RATE);
            const confirmationMessage = `<b>--- X√ÅC NH·∫¨N B√ÅN XU ---</b>\n\n- <b>T√†i kho·∫£n TTC nh·∫≠n:</b> <code>${TTC_USERNAME_NHAN}</code>\n- <b>S·ªë xu b·∫°n b√°n:</b> <code>${amount.toLocaleString('vi-VN')}</code>\n- <b>S·ªë d∆∞ b·∫°n s·∫Ω nh·∫≠n:</b> <code>${soduNhanDuoc.toLocaleString('vi-VN')} ƒë</code>\n\n‚ö†Ô∏è <b>QUAN TR·ªåNG:</b> H√£y ch·∫Øc ch·∫Øn b·∫°n ƒë√£ chuy·ªÉn <b>${amount.toLocaleString('vi-VN')} xu</b> t·ª´ t√†i kho·∫£n <b>${ttcUsername}</b> ƒë·∫øn t√†i kho·∫£n <b>${TTC_USERNAME_NHAN}</b> c·ªßa ch√∫ng t√¥i. Sau khi chuy·ªÉn, h√£y b·∫•m n√∫t "<b>X√°c Nh·∫≠n ƒê√£ Chuy·ªÉn</b>".`;
            bot.sendMessage(chatId, confirmationMessage, {
                reply_markup: { inline_keyboard: [[{ text: '‚úÖ X√°c Nh·∫≠n ƒê√£ Chuy·ªÉn', callback_data: `confirm_sell_ttc_${ttcUsername}_${amount}` }]] },
                parse_mode: 'HTML'
            });
            delete userState[userId];
            return;
        }
    }

    const nguoidungData = readJSON(NGUOIDUNG_FILE);
    const user = nguoidungData.find(u => u.id === userId);
    if (!user) return bot.sendMessage(chatId, "Vui l√≤ng b·∫•m /start ƒë·ªÉ b·∫Øt ƒë·∫ßu.");

    switch (text) {
        case 'üë§ T√†i kho·∫£n':
            const accountInfo = `<b>--- T√ÄI KHO·∫¢N ---</b>\nüÜî <b>ID:</b> <code>${user.id}</code>\nüí∞ <b>S·ªë d∆∞:</b> <code>${user.sodu.toLocaleString('vi-VN')} ƒë</code>\nüåπ <b>T·ªïng hoa h·ªìng:</b> <code>${user.tonghoahong.toLocaleString('vi-VN')} ƒë</code>`;
            bot.sendMessage(chatId, accountInfo, {
                reply_markup: { inline_keyboard: [[{ text: 'LS R√∫t Ti·ªÅn', callback_data: 'ls_rut' }, { text: 'LS N·∫°p Ti·ªÅn', callback_data: 'ls_nap' }], [{ text: 'LS Mua Xu', callback_data: 'ls_mua_xu' }, { text: 'LS B√°n Xu', callback_data: 'ls_ban_xu' }]] },
                parse_mode: 'HTML'
            });
            break;
        case 'üîÑ Mua B√°n':
            bot.sendMessage(chatId, 'Ch·ªçn h√¨nh th·ª©c giao d·ªãch:', { reply_markup: { inline_keyboard: [[{ text: '‚ô•Ô∏è Mua', callback_data: 'buy' }, { text: 'üß© B√°n', callback_data: 'sell' }]] } });
            break;
        case 'üí≥ N·∫°p R√∫t':
            bot.sendMessage(chatId, 'Ch·ªçn giao d·ªãch:', { reply_markup: { inline_keyboard: [[{ text: 'üí∏ N·∫°p ti·ªÅn', callback_data: 'deposit' }, { text: 'üí∏ R√∫t ti·ªÅn', callback_data: 'withdraw' }]] } });
            break;
        case 'ü§ù M·ªùi B·∫°n':
            bot.getMe().then((botInfo) => {
                const referralLink = `https://t.me/${botInfo.username}?start=${userId}`;
                const refData = readJSON(REF_FILE);
                const referredCount = refData[userId] ? refData[userId].length : 0;
                const referralMessage = `<b>--- M·ªúI B·∫†N B√à ---</b>\n\nüîó <b>Link gi·ªõi thi·ªáu:</b>\n<code>${referralLink}</code>\n\nüìà B·∫°n ƒë√£ m·ªùi ƒë∆∞·ª£c: <b>${referredCount}</b> ng∆∞·ªùi.`;
                bot.sendMessage(chatId, referralMessage, { parse_mode: 'HTML' });
            });
            break;
    }
});

// --- HELPER FUNCTIONS ---
const getBanks = async () => {
    try {
        const res = await axios.get('https://api.vietqr.io/v2/banks');
        return res.data.data || [];
    } catch (err) {
        console.error('‚ùå Unable to fetch bank list:', err.message);
        return [];
    }
};

const handleRutBank = async (chatId, userId) => {
    let banks = await getBanks();
    if (banks.length === 0) {
        return bot.sendMessage(chatId, '‚ö†Ô∏è H·ªá th·ªëng kh√¥ng th·ªÉ l·∫•y danh s√°ch ng√¢n h√†ng v√†o l√∫c n√†y. Vui l√≤ng th·ª≠ l·∫°i sau.');
    }

    banks = banks.slice(0, 15);

    const buttons = [];
    let row = [];
    for (const bank of banks) {
        row.push({ text: bank.shortName, callback_data: `chonbank_${bank.code}` });
        if (row.length === 3) {
            buttons.push(row);
            row = [];
        }
    }
    if (row.length > 0) { buttons.push(row); }

    userState[userId] = { action: 'rut_bank_step1' };
    bot.sendMessage(chatId, 'üè¶ Vui l√≤ng ch·ªçn ng√¢n h√†ng b·∫°n mu·ªën r√∫t ti·ªÅn v·ªÅ:', {
        reply_markup: { inline_keyboard: buttons }
    });
};

bot.onText(/\/rutbank/, (msg) => { handleRutBank(msg.chat.id, msg.from.id); });

bot.on('polling_error', (error) => console.log(`Polling Error: ${error.code} - ${error.message}`));

console.log('‚úÖ Bot started - All features fixed and restored.');
